
var appmetrics = require('appmetrics');
var http = require('https');
var httpLocal = require('http');
var monitor = appmetrics.monitor();

var intervalTime = 30000;
var isTest = true;
var testServerUrl = '';
console.log('auto-scaling node.js agent is starting!');
var latencyStats = {
	'count':   0,
	'sum':     0,
	'average': 0
};
var httpStats = {
	'count':	0,
	'duration': 0,
	'average':	0
};
var memoryStats = {
	'count': 0,
	'sum': 0,
	'average': 0
}
var cpuStats = {
	'count': 0,
	'sum': 0,
	'average': 0
}
var heapStats = {
	'count': 0,
	'usedSum': 0,
	'usedAverage': 0,
	'committed': 0,
	'maxHeap': 0,
	'heapSizeLimit':0,
	'maxSemiSpace':0,
	'maxOldSpace':0
}
var throughputStats = {
	'lastCauculateTime': new Date().getTime(),
	'requestCount': 0,
	'throughput': 0
}
var heapStats2 = {
	'count': 0,
	'sum': 0,
	'average': 0
}
monitor.on('initialized',function(env){
	env = monitor.getEnvironment();
	heapStats.maxHeap = env['max.heap.size'];
	heapStats.heapSizeLimit = env['heap.size.limit'];
	heapStats.maxSemiSpace = env['max.semi.space.size'];
	heapStats.maxOldSpace = env['max.old.space.size'];
	//maxHeap = (env['max.heap.size']/(1024*1024)).toFixed(2);
	//console.log('max heap:' + maxHeap);
});
monitor.on('eventloop',function(latency){
	console.log('latency' + latency.latency.avg);
	console.log('maxHeapSize='+(heapStats.maxHeap/(1024*1024)).toFixed(2));
	console.log('heapSizeLimit'+(heapStats.heapSizeLimit/(1024*1024)).toFixed(2));
	console.log('maxSemiSpace'+(heapStats.maxSemiSpace/(1024*1024)).toFixed(2));
	console.log('maxOldSpace'+(heapStats.maxOldSpace/(1024*1024)).toFixed(2));
	latencyStats.count++;
	latencyStats.sum += latency.latency.avg;
});
monitor.on('http', function(http) {
	console.log('time' + http.duration);
	httpStats.count++;
	throughputStats.requestCount++;
	httpStats.duration += http.duration;
});
monitor.on('memory', function (memory) {
	memoryStats.count++;
	memoryStats.sum += memory.physical;
    //console.log('['  + new Date(memory.time) + '] memory total: ' + memory.physical_total/(1024*1024)+'m, used:'+memory.physical_used/(1024*1024)+'m, free:'+memory.physical_free/(1024*1024)+'m');
});
monitor.on('cpu', function (cpu) {
	cpuStats.count++;
	cpuStats.sum += cpu.process;
    //console.log('[' + new Date(cpu.time) + '] CPU: ' + cpu.process);
});
monitor.on('gc', function (gc) {
	heapStats.commited = gc.size;
	heapStats.count++;
	heapStats.usedSum += gc.used;
	var processMem = process.memoryUsage();
    //console.log('[' + new Date(gc.time) + '] GC: heap: type' + gc.type +', heapSize:'+(gc.size/(1024*1024)).toFixed(2)+'m, usedHeap:'+(gc.used/(1024*1024)).toFixed(2)+'m, duration:'+gc.duration/(1000));
	//console.log('[HEAP2] total: ' +  (processMem.heapTotal/(1024*1024)).toFixed(2) + ' used:' + (processMem.heapUsed/(1024*1024)).toFixed(2));
});

function getApplicationEnv(){
	var appInfo = JSON.parse(process.env.VCAP_APPLICATION || "{}");
	return appInfo;
}
function getServiceEnv(){
    var regex = /(icapmonitor|AppWatch|Auto(.*)Scaling)/;
	var services = JSON.parse(process.env.VCAP_SERVICES || "{}");
	for( key in services){
		if(regex.test(key)){
			return services[key][0]['credentials'];
		}
	}
	return null;
}

var appEnv = getApplicationEnv();
var serviceEnv = getServiceEnv();
function parseUrlToHostPort(){
	var result = new Array();
	var host = serviceEnv['url'];
	var port = '443';
	var regexp =  /(http:\/\/)|(https:\/\/)/;
	host = host.replace(regexp,'');
	var hostPortArray = host.split(':');
	if(hostPortArray.length == 2){
		host = hostPortArray[0];
		port = hostPortArray[1];
	}
	result.push(host);
	result.push(port);
	return result;
}
function sendMetrics(object){
/*
	var host = serviceEnv['url'];
	var port = '80';
	var regexp =  /(http:\/\/)|(https:\/\/)/;
	host = host.replace(regexp,'');
	var hostPortArray = host.split(':');
	if(hostPortArray.length ==2){
		host = hostPortArray[0];
		port = hostPortArray[1];
	}*/
	var hostPort = parseUrlToHostPort();
	var host = hostPort[0];
	var port = hostPort[1];
	var agentUserName = serviceEnv['agentUsername'];
	var agentPassword = serviceEnv['agentPassword'];
	var authorization = 'Basic ' + new Buffer(agentUserName + ':' + agentPassword).toString("base64");
	var jsonStr = JSON.stringify(object);
	console.log('metrics: ' + jsonStr);
	var headers = {
		  'Content-Type': 'application/json',
		  'Content-Length': jsonStr.length,
		  'Authorization': authorization
	};
	var options = {
	  host: host,
	  port: port,
	  path: '/services/agent/report',
	  method: 'POST',
	  headers: headers
	};
	if('443' != port){
		options.port = port;
	}
	if('80' == port || '9080' == port){
		http = httpLocal;
	}
	console.log(JSON.stringify(options));
	var req=http.request(options,function(res){
		res.setEncoding('utf-8');
		var responseString = '';
		console.log('-----resp code ' + res.statusCode);
		res.on('data', function(data) {
			responseString += data;
		});
		res.on('end', function() {
			//var resultObject = JSON.parse(responseString);
			//console.log('-----resBody-----',responseString);
		});
		req.on('error', function(e) {
			// TODO: handle error.
			//console.log('-----error-------',e);
		});
	});
	req.write(jsonStr);
	req.end();
}
function notifyStatus(){
	//var host = serviceEnv['url'];
	//var regexp =  /(http:\/\/)|(https:\/\/)/;
	//host = host.replace(regexp,'');
	var hostPort = parseUrlToHostPort();
	var host = hostPort[0];
	var port = hostPort[1];
	var appId = serviceEnv['app_id'];
	var agentUserName = serviceEnv['agentUsername'];
	var agentPassword = serviceEnv['agentPassword'];
	var authorization = 'Basic ' + new Buffer(agentUserName + ':' + agentPassword).toString("base64");
	var headers = {
		  'Authorization': authorization
	};
	var options = {
	  host: host,
	  path: '/services/agent/status/' + appId,
	  method: 'PUT',
	  headers: headers
	};

	var req=http.request(options,function(res){
		res.setEncoding('utf-8');
		var responseString = '';
		res.on('data', function(data) {
			responseString += data;
		});
		res.on('end', function() {
		//	var resultObject = JSON.parse(responseString);
			//console.log('-----resBody-----',responseString);
		});
		req.on('error', function(e) {
			// TODO: handle error.
			//console.log('-----error-------',e);
		});
	});
	req.write(jsonStr);
	req.end();
}
function refreshHeartBeat(){
	var host = serviceEnv['url'];
	var regexp =  /(http:\/\/)|(https:\/\/)/;
	host = host.replace(regexp,'');
	var appId = serviceEnv['app_id'];
	var serviceId = serviceEnc['service_id'];
	var agentUserName = serviceEnv['agentUsername'];
	var agentPassword = serviceEnv['agentPassword'];
	var authorization = 'Basic ' + new Buffer(agentUserName + ':' + agentPassword).toString("base64");
	var headers = {
		  'Content-Type': 'application/json',
		  'Authorization': authorization
	};
	var options = {
	  host: host,
	  path: '/v1/agent/config/' + serviceId + '/' + appId + '?appType=java',
	  method: 'GET',
	  headers: headers
	};

	var req=http.request(options,function(res){
		res.setEncoding('utf-8');
		var responseString = '';
		res.on('data', function(data) {
			responseString += data;
		});
		res.on('end', function() {
			//var resultObject = JSON.parse(responseString);
			//console.log('-----resBody-----',responseString);
		});
		req.on('error', function(e) {
			// TODO: handle error.
			//console.log('-----error-------',e);
		});
	});
	req.write(jsonStr);
	req.end();
}
function cauculate(){
	if(latencyStats.sum > 0 && latencyStats.count > 0) {
		latencyStats.average = latencyStats.sum / latencyStats.count;
		latencyStats.count = 0;
		latencyStats.sum = 0;
	}
	else{
		latencyStats.count = 0;
		latencyStats.sum = 0;
		latencyStats.average = 0;
	}
	if (httpStats.duration > 0 && httpStats.count > 0) {
		httpStats.average = httpStats.duration / httpStats.count + latencyStats.average;
		//console.log('[HTTP] Count: ' + httpStats.count + ', average duration: ' + httpStats.average);
		httpStats.count = 0;
		httpStats.duration = 0;
		
	}
	else{
		httpStats.count = 0;
		httpStats.duration = 0;
		httpStats.average = 0;
	}
	if(memoryStats.sum > 0 && memoryStats.count > 0){
		memoryStats.average = memoryStats.sum / memoryStats.count;
		//console.log('[MEMORY] Count: ' + memoryStats.count + ', average memory: ' + (memoryStats.average/(1024*1024)).toFixed(2));
		memoryStats.count = 0;
		memoryStats.sum = 0;
	}
	else{
		memoryStats.count = 0;
		memoryStats.sum = 0;
	}
	if(cpuStats.sum > 0 && cpuStats.count > 0){
		cpuStats.average = cpuStats.sum / cpuStats.count;
		//console.log('[CPU] Count: ' + cpuStats.count + ', average cpu time : ' + cpuStats.average);
		cpuStats.count = 0;
		cpuStats.sum = 0;
		
	}
	else{
		cpuStats.count = 0;
		cpuStats.sum = 0;
	}
	if(heapStats.usedSum > 0 && heapStats.count > 0){
		heapStats.usedAverage = heapStats.usedSum / heapStats.count;
		//console.log('[HEAP] Count: ' + heapStats.count + ', average heap : ' + (heapStats.usedAverage/(1024*1024)).toFixed(2));
		heapStats.count = 0;
		heapStats.usedSum = 0;
	}
	else{
		heapStats.count = 0;
		heapStats.usedSum = 0;
	}
	if(throughputStats.requestCount > 0){
		var curTime = new Date().getTime();
		var duration = curTime - throughputStats.lastCauculateTime;
		throughputStats.throughput = throughputStats.requestCount / (duration / 1000);
		throughputStats.lastCauculateTime = curTime;
		throughputStats.requestCount = 0;
	}
	else{
		throughputStats.requestCount = 0;
		throughputStats.throughput = 0;
	}
}
function createMetricsObj(category,group,name,value,unit,desc){
	var obj = new Object();
	obj.category = category;
	obj.group = group;
	obj.name = name;
	obj.value = value;
	obj.unit = unit;
	obj.desc = desc;
	obj.timestamp = new Date().getTime();
	return obj;
}
function constructMetrics(){
	var applicationName = appEnv['application_name'];
	var applicationId = appEnv['application_id'];
	var applicationInstanceIndex = appEnv['instance_index'];
	var applicationInstanceId = appEnv['instance_id'];
	var serviceId = serviceEnv['service_id'];
	var appType = 'nodejs';
	var metricCategory = 'nodejs';
	var metrics = new Array();
	var cpuObj = createMetricsObj(metricCategory,'ProcessCpuLoad','ProcessCpuLoad',cpuStats.average*100,'%%','');
	var memoryObj = createMetricsObj(metricCategory,'memory','memory',memoryStats.average,'Bytes','');
	var initHeapObj = createMetricsObj(metricCategory,'HeapMemoryUsage','init',0,'Bytes','');
	var commitedHeapObj = createMetricsObj(metricCategory,'HeapMemoryUsage','used',heapStats.usedAverage,'Bytes','');
	var usedHeapObj = createMetricsObj(metricCategory,'HeapMemoryUsage','committed',heapStats.commited,'Bytes','');
	var maxHeapObj = createMetricsObj(metricCategory,'HeapMemoryUsage','max',heapStats.maxHeap,'Bytes','');
	var throughputObj = createMetricsObj(metricCategory,'Web','throughput',throughputStats.throughput,'','');
	var responseTimeObj = createMetricsObj(metricCategory,'Web','responseTime',httpStats.average,'ms','');
	var eventLoopLatencyObj = createMetricsObj(metricCategory,'Web','eventloopLatency',latencyStats.average,'ms','');
	metrics.push(cpuObj);
	metrics.push(memoryObj);
	metrics.push(initHeapObj);
	metrics.push(commitedHeapObj);
	metrics.push(usedHeapObj);
	metrics.push(maxHeapObj);
	metrics.push(throughputObj);
	metrics.push(responseTimeObj);
	metrics.push(eventLoopLatencyObj);
	var obj = new Object();
	obj.appId = applicationId;
	obj.appName = applicationName;
	obj.appType = appType;
	obj.serviceId = serviceId;
	obj.instanceIndex = applicationInstanceIndex;
	obj.instanceId = applicationInstanceId;
	obj.timestamp = new Date().getTime();
	obj.metrics = metrics;
	return obj;
	
} 
function reportJob(){
	if(serviceEnv == null){
		console.log('Please bind auto-scaling service!');
		return;
		}
	cauculate();
	var metrics = constructMetrics();
	sendMetrics(metrics);
}
var interval = setInterval(function() {
	reportJob();
	},intervalTime);
setInterval(function(){
	var flag = false;
	if(true == flag){
		clearInterval(interval);
		interval = setInterval(function() {
		reportJob();
		},intervalTime);
	}
	
},intervalTime);
module.exports.httpStats = httpStats;
module.exports.cpuStats = cpuStats;
module.exports.memoryStats = memoryStats;
module.exports.heapStats = heapStats;
module.exports.throughputStats = throughputStats;